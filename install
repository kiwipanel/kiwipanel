#!/bin/bash
#######################################################
# KiwiPanel Installer v0.0.1
# To install KiwiPanel type:
# curl -sLO # curl -sLO https://install.kiwipanel.org/install && chmod +x install && sudo bash install
# @author: Vuong Nguyen and contributors
# @website: https://kiwipanel.org
# @since: 2024
#######################################################
clear
date
LANG=en_US.UTF-8
locale-gen en_US.UTF-8 
export LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8

# Configuration########################################
readonly INSTALL_VERSION="0.1.1" 
readonly KIWIPANEL_VERSION="0.1.1"
readonly KIWIPANEL_PORT=8443

# Utilities ###########################################
function PrintGreen() {
    local GREEN='\033[0;32m'
    local NC='\033[0m'
    local content="${1}"
    printf "${GREEN}${content}${NC}\n"
}
function PrintRed() {
    local RED='\033[0;31m'
    local NC='\033[0m'
    local content="${1}"
    printf "${RED}Error: ${content}${NC}\n"
}

function PrintWarning() {
    local YELLOW_BROWN='\033[38;5;179m'  # ANSI color code for yellow-brown
    local NC='\033[0m'  # Reset to default color
    local content="${1}"
    printf "${YELLOW_BROWN}Warning: ${content}${NC}\n"
}

# Check for sudo/root privileges######################################
if [[ $(whoami) != "root" ]]; then	
    PrintRed "You should install KiwiPanel as root or using sudo command."
    exit 1
fi

# Set the Go version you want to install
GO_VERSION="1.21.6"  # Update this to the desired Go version
# Set the Go installation directory
GO_INSTALL_DIR="/usr/local"
# Detect the system's architecture
ARCHITECTURE=$(uname -m)

# Download and install Go
function install_go() {
    # Check if Go is already installed
    if type go &> /dev/null; then
        installed_version=$(go version | awk '{print $3}')
        echo "Go is already installed. Version: ${installed_version}"
        return
    fi

    # Download Go binary based on architecture
    case "$ARCHITECTURE" in
        "x86_64")
            GO_BINARY="go${GO_VERSION}.linux-amd64.tar.gz"
            ;;
        "aarch64")
            GO_BINARY="go${GO_VERSION}.linux-arm64.tar.gz"
            ;;
        "armv7l")
            GO_BINARY="go${GO_VERSION}.linux-armv6l.tar.gz"
            ;;
        *)
            echo "Unsupported architecture: $ARCHITECTURE"
            exit 1
            ;;
    esac

    wget "https://go.dev/dl/${GO_BINARY}" -O /tmp/go.tar.gz
    # Extract Go binary
    sudo tar -C "${GO_INSTALL_DIR}" -xzf /tmp/go.tar.gz
    # Add Go binary path to system profile.d
    echo "export PATH=\$PATH:${GO_INSTALL_DIR}/go/bin" | sudo tee "/etc/profile.d/go.sh"
    source "/etc/profile.d/go.sh"
    # Cleanup
    rm /tmp/go.tar.gz
    echo "Go ${GO_VERSION} has been installed for ${ARCHITECTURE} architecture."
}


function check_install_go(){
    PrintGreen "Start to install Golang..."
    sleep 3
    # Check if Go is already installed
    #if command -v go &> /dev/null; then
    if type go &> /dev/null; then
        installed_version=$(go version | awk '{print $3}')
        echo "Go is already installed. Version: ${installed_version}"
    else
        # Add some debugging output
        echo "Go not found in PATH. Trying to install..."
        # Install Go without asking for confirmation
        install_go
        # Check again after installation
        if command -v go &> /dev/null; then
            installed_version=$(go version | awk '{print $3}')
            echo "Go is installed successfully. Version: ${installed_version}"
        else
            echo "There was an issue installing Go. Please check the script and try again."
        fi
    fi
}

#
kiwi_config_log="/home/state/kiwipanel.log"
kiwi_config_file="/home/state/kiwipanel.conf"
kiwi_current_state="/home/state"
kiwi_current_backup="/home/backup"

function run_and_check() {
    local command_to_run="$1"    
    $command_to_run    
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        PrintGreen "Command $command_to_run succeeded"
    else
        PrintRed "Command $command_to_run failed with exit code $exit_code"        
        if [ $exit_code -eq 5 ]; then
            # Exit code 5 typically indicates that the service is not loaded
            PrintWarning "Service is not loaded or does not exist."
        else
            exit 1
        fi
    fi
}

#Turn off the current service if any, make sure that it works
run_and_check "sudo systemctl stop kiwipanel"

function move_nested_file() {
    # Check if both source and destination folders are provided
    if [ $# -ne 2 ]; then
        echo "Usage: moving folder : source_folder destination_folder"
        return 1
    fi
    local source_folder="$1"
    local destination_folder="$2"
    
    # Check if the source folder exists
    if [ ! -d "$source_folder" ]; then
        echo "Source folder '$source_folder' not found."
        return 1
    fi

    # Check if the source folder is empty
    if [ -z "$(ls -A "$source_folder")" ]; then
        echo "Source folder '$source_folder' is empty. Nothing to move."
        return 0
    fi

    # Check if the destination folder exists; create it if not
    if [ ! -d "$destination_folder" ]; then
        mkdir -p "$destination_folder" || return 1
    fi

    # Move the content of the source folder to the destination folder
    mv "$source_folder"/* "$destination_folder"/ || return 1
    echo "Nested content of '$source_folder' moved to '$destination_folder'."
}
function rename_folder() {
    if [ $# -ne 1 ]; then
        echo "Usage: rename_folder <old_folder_name>"
        return 1
    fi

    old_folder_name="$1"
    current_datetime=$(date +"%Y_%m_%d_%H_%M")
    new_folder_name="${old_folder_name%_*}_${current_datetime}"

    if [ ! -d "$old_folder_name" ]; then
        echo "Error: Folder '$old_folder_name' not found."
        return 1
    fi

    echo "Renaming folder $old_folder_name to $new_folder_name..."
    mv "$old_folder_name" "$new_folder_name"

    if [ $? -eq 0 ]; then
        echo "Rename operation successful."

        # Check if new_folder_name is empty and delete it
        if [ -z "$(ls -A "$new_folder_name")" ]; then
            rmdir "$new_folder_name"
            echo "Deleted empty folder: $new_folder_name"
        fi

    else
        echo "Error: Failed to rename the folder."
        return 1
    fi
}


function create_dir_bash() {
    mkdir -p /home/state
    chmod 755 /home/state    
    mkdir -p /home/state/database
    chmod 775 /home/state/database
    chown -R $(whoami):$(whoami) /home/state/database    
    touch "$kiwi_config_log"
    touch "$kiwi_config_file"    
}

function create_dir_backup() {
    mkdir -p /home/backup
    chmod 755 /home/backup    
}

function backup(){
    if [ -d "$kiwi_current_state" ]; then
        echo "The folder /home/state exists, starting backup the current data: $kiwi_current_state"
        if [ ! -d "$kiwi_current_backup" ]; then        
            echo "Folder kiwi_current_backup, does not exists, create it!"     
            create_dir_backup  
            echo "Starting backup !"
            sleep 3
            move_nested_file $kiwi_current_state $kiwi_current_backup
        else            
            echo "Folder /home/state exists, just backup : $kiwi_current_state"
            PrintGreen "Step 1: Rename the backup folder"
            sleep 3
            rename_folder $kiwi_current_backup
            PrintGreen "Step 2: Create a new empty backup folder"
            sleep 3
            move_nested_file $kiwi_current_state $kiwi_current_backup
        fi
    else
        create_dir_bash
        create_dir_backup
        PrintGreen "Greate!. It seems you are installing KiwiPanel for the first time!"
        echo "2 folders: $kiwi_current_state, $kiwi_current_backup are created"
    fi
}
backup

#Logging...
exec 19>>"$kiwi_config_log"
BASH_XTRACEFD=19
set -x

# Setting and declaring

kiwipanel_d_start_time=$(date +%s)
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m' #NC: Not color: reset color to the default
IPADDRESS=`curl -s -L -sk --connect-timeout 10 --retry 3 --retry-delay 0 http://cpanel.net/showip.cgi`
readonly DIR=$(pwd)
readonly HOSTNAME=$(hostname)
# Check the current distro and the kernel
readonly distro=$(grep -oP 'PRETTY_NAME="\K[^"]+' /etc/os-release | cut -f1 -d' ')
readonly kernel_version=$(uname -r)
readonly distro_version=`echo $(lsb_release -c | cut -d':' -f 2)`
#Reference: https://www.cloudron.io/get.html
readonly MINIMUM_DISK_SIZE_GB="10" 
readonly MINIMUM_MEMORY="420" #lightsail 423MB      
readonly curl="curl --fail --connect-timeout 20 --retry 10 --retry-delay 2 --max-time 2400"
readonly rootfs_type=$(LC_ALL=C df --output=fstype / | tail -n1)
readonly physical_memory=$(LC_ALL=C free -m | awk '/Mem:/ { print $2 }')
readonly disk_size_bytes=$(LC_ALL=C df --output=size / | tail -n1)
readonly disk_size_gb=$((${disk_size_bytes}/1024/1024))
readonly current_swap=`free | awk '/^Swap:/ {print $3}'`

# verify the system has minimum requirements met
if [[ "${rootfs_type}" != "ext4" && "${rootfs_type}" != "xfs" ]]; then
    echo "Error: KiwiPanel requires '/' to be ext4 or xfs" # see #364
    exit 1
fi

if [[ "${physical_memory}" -lt "${MINIMUM_MEMORY}" ]]; then
    echo "Error: KiwiPanel requires atleast 512MB physical memory"
    exit 1
fi

if [[ "${disk_size_gb}" -lt "${MINIMUM_DISK_SIZE_GB}" ]]; then
    echo "Error: KiwiPanel requires atleast 10GB disk space (Disk space on / is ${disk_size_gb}GB)"
    exit 1
fi

function generate_random_string() {
    cat /dev/urandom | tr -dc 'a-z0-9' | head -c 9
}

readonly kiwipanel_passcode=$(generate_random_string)
function change_directory() {
    cd "$1" || return
}

function tracking(){                
    echo "install:$kiwipanel_d_start_time" >> "$kiwi_config_file"    
    echo "Current epoch time saved to $kiwi_config_file"
}

###################################################################################
function welcome(){    
    printf "${GREEN}========================================================\n${NC}"
    echo   "                   KIWIPANEL.ORG Scripts                  "
    echo   "            Auto Install & Optimize LEMP Stack            "
    printf "${GREEN}========================================================\n${NC}"        
    echo ""    
    PrintGreen "Installing KiwiPanel..."
    sleep 3
}

# Control Panel path
# @credit: https://github.com/sanvu88/lempstack/blob/master/install
CPANEL="/usr/local/cpanel/cpanel"
DIRECTADMIN="/usr/local/directadmin/custombuild/build"
PLESK="/usr/local/psa/version"
WEBMIN="/etc/init.d/webmin"
SENTORA="/root/passwords.txt"
HOCVPS="/etc/hocvps/scripts.conf"
VPSSIM="/home/vpssim.conf"
EEV3="/usr/local/bin/ee"
WORDOPS="/usr/local/bin/wo"
KUSANAGI="/home/kusanagi"
CWP="/usr/local/cwpsrv"
VESTA="/usr/local/vesta/"
EEV4="/opt/easyengine"
LARVPS="/etc/larvps/.info.conf"
TINO="/opt/tinopanel"

function check_panel_script(){
  PrintGreen "Checking the current script or panel, if any...."
  sleep 3;  
  if [ -f /var/cpanel/cpanel.config ]; then    
    PrintRed "Your server installed WHM/Cpanel, please reinstall to use KiwiPanel"
    exit
    fi

    if [ -f /etc/psa/.psa.shadow ]; then    
    echo "Your server installed Plesk, please reinstall to use KiwiPanel."
    exit
    fi

    if [ -f /etc/init.d/directadmin ]; then    
    echo "Your server installed DirectAdmin, please reinstall to use KiwiPanel."
    exit
    fi

    if [ -f /etc/init.d/webmin ]; then    
    echo "Your server installed Webmin, please reinstall to use KiwiPanel."
    exit
    fi
    PrintGreen "That is good! The VPS is freshly installed. You are good to go..."
    sleep 2
}
function check_architecture(){
    #Check the ARCHITECTURE
    #Ref: https://raw.githubusercontent.com/runtipi/runtipi/master/scripts/install.sh
    # Not supported on 32 bits systems. 
    # Note: aarch64 [ARM 64-bit (also known as AArch64), armv7: 32-bit ARM]
    local ARCHITECTURE="$(uname -m)"
    if [[ "$ARCHITECTURE" == "armv7"* ]] || [[ "$ARCHITECTURE" == "i686" ]] || [[ "$ARCHITECTURE" == "i386" ]]; then
    PrintRed "KiwiPanel currently does not support the 32 bits systems"
    exit 1
    fi
}
function check_os() {
    echo "Your current Kernel: ${kernel_version}"
    echo "Your current Linux distro: ${distro}"
    if [[ "$distro" != "Ubuntu" ]]; then
        echo "$(tput setaf 1)The current version of KiwiPanel only works on Ubuntu.$(tput sgr0)"
        exit 1
    fi
}
function check_condition_before_install(){
    PrintGreen "Evaluating your VPS before installing KiwiPanel....."
    sleep 2    
    check_os
    check_architecture
    check_panel_script
}

function check_file_availability() {
  if [ -e "$1" ]; then
    return 0  # File exists, return true (0)
  else
    return 1  # File does not exist, return false (non-zero)
  fi
}

#Create swap
function create_swap() {
    # Check if a swap file already exists
    if [ -e /swapfile ]; then
        echo "Swap file already exists. Skipping creation."
        return
    fi

    # Get the total amount of RAM in kilobytes
    total_ram_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    # Calculate the size for the swap file (assuming the same size as RAM)
    swap_size_kb=$total_ram_kb
    # Create a swap file
    sudo fallocate -l ${swap_size_kb}K /swapfile
    # Set appropriate permissions for the swap file
    sudo chmod 600 /swapfile
    # Make it a swap file
    sudo mkswap /swapfile
    # Enable the swap file
    sudo swapon /swapfile
    # Add an entry to /etc/fstab to make the swap file persistent
    echo "/swapfile none swap sw 0 0" | sudo tee -a /etc/fstab
}

function UpdateUbuntu(){
    printf " \n"
    echo "$(tput setaf 2)Updating the system....$(tput sgr0)"     
    sleep 3;
    sudo apt-get update && sudo apt-get -y upgrade
}
function BaseCentos(){   
    printf " \n"
    echo "$(tput setaf 2)Installing the base tools....$(tput sgr0)" 
    sleep 3;         
    sudo yum install wget curl git zip unzip nano -y
}
function BaseUbuntu(){    
    printf " \n"
    echo "$(tput setaf 2)Installing the base tools....$(tput sgr0)" 
    sleep 3;    
    sudo apt install wget curl git zip unzip nano -y
}

 # Install the base system for the specified distribution.
function install_base(){      
    if [ "$distro" == "Ubuntu" ]; then
        UpdateUbuntu
        BaseUbuntu
    elif [ "$distro" == "AlmaLinux" ] || [ "$distro" == "Centos" ] || [ "$distro" == "RockyLinux" ]; then
        BaseCentos
    fi
}

#Just in case it is needed
function remove_apache2(){
    #The || true at the end ensures that the entire command sequence returns a successful exit status (0), 
    # even if the systemctl command returns a non-zero exit status.
    sudo systemctl --quiet disable --now apache2 || true
    sudo service apache2 stop
    sudo apt remove --autoremove apache2 -y
    sudo apt purge apache2 apache2-utils -y
    sudo apt remove apache2 apache2-utils -y
    sudo apt autoremove apache2 apache2-utils -y
    sudo rm -r /usr/sbin/apache2
    sudo rm -r /usr/lib/apache2
    sudo rm -r /etc/apache2
    sudo rm -r /usr/share/man/man8/apache2.8.gz
}

function clone_repository(){  
    PrintGreen "Cloning the code from github.com/kiwipanel"
    cd /home
    sudo git clone https://github.com/kiwipanel/scaffolding.git
    cd scaffolding
    go build -o bin/kiwipanel
}

function open_port() {
    local PORT_NUMBER="$1"
    # Check if iptables is installed
    if ! command -v iptables &> /dev/null; then
        echo "Error: iptables not found. This function requires iptables."
        return 1
    fi

    # Check if the function is run as root
    if [ "$(id -u)" -ne 0 ]; then
        echo "Error: This function must be run as root. Use sudo."
        return 1
    fi

    # Open the specified port
    iptables -A INPUT -p tcp --dport $PORT_NUMBER -j ACCEPT

    # Save the iptables rules to persist across reboots (this may vary based on your distribution)
    service iptables save &> /dev/null  # For RHEL/CentOS
    # or
    iptables-save > /etc/iptables/rules.v4  # For Debian/Ubuntu

    echo "Port $PORT_NUMBER opened successfully."
}

function remove_file() {
    cd /usr/bin
    if check_file_availability "$1"; then
        sudo rm "$1"
    fi
}
function move_file() {
    # usr: unix system resources
    sudo mv -v kiwi /usr/bin
    sudo chmod 755 /usr/bin/kiwi    

}
function create_passcode(){  
  # Append the random string to the file  
  echo "passcode:$kiwipanel_passcode" >> "$kiwi_config_file"     
  PrintGreen "Passcode $kiwipanel_passcode is generated and save to kiwipanel.conf"
}
function create_database() {
    folder_path="/home/state/database"    
    file_path="$folder_path/kiwipanel.sqlite"

    # Create the folder if it doesn't exist
    if [ ! -d "$folder_path" ]; then
        mkdir -p "$folder_path"
        chmod 775 "$folder_path"
        chown -R $(whoami):$(whoami) "$folder_path"
        echo "Folder created: $folder_path"
    else                
        # Remove the source folder
        rm -r "$folder_path" || return 1
        # Create a new one
        mkdir -p "$folder_path"
        chmod 775 "$folder_path"
        chown -R $(whoami):$(whoami) "$folder_path"
        echo "Database Folder - recreated: $folder_path"
    fi

    # Create the file if it doesn't exist
    if [ ! -e "$file_path" ]; then
        touch "$file_path"
        chmod 664 "$file_path"  # Adjust permissions to allow all users to read and write
        chown $(whoami):$(whoami) "$file_path"
        echo "File created: $file_path"
    else
        echo "File already exists: $file_path"
        chmod 664 "$file_path"  # Adjust permissions in case the file already exists
        chown $(whoami):$(whoami) "$file_path"
    fi
}
function create_state(){
  create_passcode
  create_database
}
readonly kiwipanel_service=$(cat <<EOF
[Unit]
Description=Kiwipanel application
[Service]
Type=simple
Restart=always
RestartSec=5s
WorkingDirectory=/home/scaffolding/bin
ExecStart=/home/scaffolding/bin/kiwipanel start
[Install]
WantedBy=multi-user.target
EOF
)
function create_systemd(){
    PrintGreen "Creating systemd-based service for running kiwipanel..."
    sleep 3
    local file_path="/etc/systemd/system/kiwipanel.service"    
    echo "$kiwipanel_service" > "$file_path"    #write file
    echo "File $file_path created successfully."
}
function start_systemd(){
    create_systemd
    #sudo systemctl daemon-reload
    run_and_check "sudo systemctl daemon-reload"
    #sudo systemctl start kiwipanel
    run_and_check "sudo systemctl start kiwipanel"    
    #Will restart automatically when VPS restarts
    #sudo systemctl enable kiwipanel 
    run_and_check "sudo systemctl enable kiwipanel"
}

function setup_kiwipanel(){  
# Check if there is any other non-root process running on the port KIWIPANEL_PORT
  local KIWIPANEL_RUNNING=$(lsof -u^root -i:"$KIWIPANEL_PORT" -P -n -sTCP:LISTEN)
  echo "KIWIPANEL_RUNNING: $KIWIPANEL_RUNNING"
  if [ ! -z "${KIWIPANEL_RUNNING}" ]; then
    PrintRed "Cannot install KiwiPanel. Some other process is running on port $KIWIPANEL_PORT which does not belong to root!."
    exit 1
  fi
  successMessage
}

function successMessage(){    
    tracking
    printf " \n"    
    PrintGreen "Kiwiscript has been successfully installed on your VPS!"
    kiwipanel_d_end_time=$(date +%s)    
    elapsed=$((kiwipanel_d_end_time - kiwipanel_d_start_time))     
    echo "$(tput setaf 2)Total time installed: ${elapsed} seconds.$(tput sgr0)"      
    printf " \n"     
    echo "    
    "$(tput setaf 2)================================Install KiwiPanel Done!==============================$(tput sgr0)"        
    
    Register and Login at : http://$IPADDRESS:$KIWIPANEL_PORT/$kiwipanel_passcode     

    "$(tput setaf 2)=====================================================================================$(tput sgr0)"    
    "
}

clean_up(){  
   #Clean the history of the commands that have been used during the current shell session.
  history -c 
   # Clean the local repository of retrieved package files
  apt clean
  #Remove the script itself
  rm $0
  PrintGreen "Cleaning up is done!"
}

#install nginx https://gist.github.com/Dryam/3cd2e55a19e1954f1433
welcome
check_condition_before_install
create_swap
install_base
remove_apache2
check_install_go
remove_file "kiwi"
clone_repository
move_file
open_port `$KIWIPANEL_PORT`
create_state
start_systemd
setup_kiwipanel
# Set up trap to call cleanUp function on script exit (EXIT signal)
trap clean_up EXIT

